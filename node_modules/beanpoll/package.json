{
  "name": "beanpoll",
  "description": "Routing with syntactic sugar",
  "version": "0.2.18",
  "author": {
    "name": "Craig Condon"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/crcn/beanpoll.js.git"
  },
  "directories": {
    "lib": "./lib"
  },
  "dependencies": {
    "disposable": "*",
    "crema": "<0.2.0",
    "underscore": "*",
    "dolce": "<0.2.0",
    "outcome": "<0.2.0"
  },
  "devDependencies": {
    "vows": "<0.7.0",
    "outcome": "<0.2.0",
    "disposable": "0.0.1"
  },
  "main": "./lib/index.js",
  "readme": "## Beanpole - Routing framework      \n\n\n### Motivation\n\n- Abstract communication between parts of an application\n\t- keeps code modular\n\t- works in-app, or with other protocols: amqp, http, etc.\n\nThis:\n\n```javascript\n\nrouter.on({\n\t\n\t/**\n\t */\n\n\t'pull auth/user': function(req, res) {\n\t\t//auth here\n\t},\n\n\t/**\n\t */\n\n\t'pull auth/user -> add/photos': function(req, res) {\n\t\t//add photos here\n\t}\n})\n```\n\n\nVersus somethine like this:\n\n```javascript\n\n\nvar addPhotos = function(req, res) {\n\tauthUser(req, res, function() {\n\t\t//do stuff here\n\t});\n}\n\n```\n\n\n\n### Projects using Beanpole\n\n- [celeri](https://github.com/crcn/celeri) - CLI library\n- [bonsai](https://github.com/crcn/bonsai) - application server\n- [leche](https://github.com/crcn/leche) - Framework to build frontend / backend applications with the same code.\n- [daisy](https://github.com/crcn/daisy) - Expose beanpole to: http, websockets, amqp (rabbitmq), etc.    \n- [beandocs](https://github.com/crcn/beandocs) - Generate documentation from your beanpole route comments.\n- [beanprep](https://github.com/crcn/beanprep) - Scans beans in a given directory, and installs their dependencies. \n- [cupboard](https://github.com/crcn/beanprep) - Reverse package manager.       \n\n### Beanpole ports\n\n- [Actionscript](https://github.com/crcn/beanpole.as)  \n- [C++](https://github.com/crcn/beanpoll)     \n\n### Overview          \n\n\n![Alt ebnf diagram](http://i.imgur.com/v1wdO.png)\n                \n\nThe basic route consists of a few parts: the `type` of route, and the `channel`. Here are some examples:\n\n\trouter.on('pull hello/:name', ...);\n\t\nand\n\n\trouter.on('push hello/:name', ...);           \n\t\n\n#### Push Routes:  \n\n- Used to broadcast a message, or change (1 to many).\n- Doesn't expect a response.    \n- Multiple listeners per route.         \n\n#### Pull Routes:\n\n- Used to request data from a particular route (1 to 1).\n- Expects a response.\n- One listener per route. \n- examples:\n\t- request to http-exposed route       \n\t\n#### Collect Routes:\n\n- Used to request data from many listeners (1 to many, similar to pull).\n- Expects a response.\n\n## Error Handling\n\n\n```javascript\n\n\nfunction auth(credits, callback) {\n\t\n\tif(credits.user != 'user' || credits.pass != 'pass') return callback(new Error('invalid credits'));\n\n\tcallback(false, { user: 'user', pass: 'pass' });\n}\n\n\nrouter.on({\n\t\n\t'pull authenticate': function(req, res) {\n\t\t\n\t\t//don't bother handling errors - done by response\n\t\tauth(req.query, res.success(function(user) {\n\t\t\t\n\t\t\tres.end(user);\n\n\t\t}));\n\t}\n})\n\n\n\n//error\nvar req = router.request('authenticate').\nerror(function(err) {\n\tconsole.log(err.stack);\n}).\nsuccess(function(response) {\n\tconsole.log(response);\n}).\nquery({ user: 'user', pass: 'bad pass' }).\npull();\n```\n\n\n## Custom Routes\n\nYou can easily create custom route handlers. Take [celeri](/crcn/celeri) for example:\n\n\n\n```javascript\n\nvar beanpoll = require('beanpoll'),\nstructr = require('structr');\n\n//handles the message, response, and middleware\nvar CmdMessenger = structr({\n\t\n\t_next: function(middleware) {\n\t\t\n\t\tvar self = this;\t\n\n\t\ttry {\n\n\t\t\t//call the command handler, and wrap the LAST parameter as a next function\n\t\t\tmiddleware.listener(Structr.copy(middleware.params, data), function() {\n\t\t\t\treturn self.next();\t\n\t\t\t});\t\t\n\n\t\t} catch(e) {\n\t\t\tself.response.error(e)\n\t\t}\n\n\t}\n\n}, beanpoll.Messenger);\n\n\n//the \"Event Emitter\"\nvar CmdDirector = structr({\n\n\t_newMessenger: function(message, middleware) {\n\t\treturn new CmdMessenger(message, middleware, this);\n\t}\n\n}, beanpoll.Director);\n\n\n\nvar router = beanpoll.router();\n\n\n//use the new plugin\nrouter.use(function() {\n\treturn {\n\t\tname: 'console',\n\t\tdirector: new CmdDirector('celeri', router)\n\t}\n});\n\n//use it:\nrouter.on('console say/hello', function(data, next) {\n\t//do stuff here\n});\n\n````     \n           \nMiddleware can also be specified without using the token: `->`.An example:\n\n\n````javascript\n    \nrouter.on({               \n\t\n\t/**\n\t */\n\t\n\t'pull my/*': function()\n\t{\n\t\t//authorize user\n\t},  \n\t\n\t/**\n\t */\n\t\n\t'pull my/profile': function()\n\t{                 \n\t\t//goes through authorization first \n\t}\n});\n\n````                                                                         \n                                                                                                \nProviding a wildcard `*` tells the router that **anything** after the route must go through it.     \n\n### Managing very long routes\n\nYou may run into a route which looks like this:\n\n```javascript\nrouter.on({\n\t'pull -public -method=POST remove/cache/subscribers -> profile/validate/SAVE_ARTICLE -> groups/:group/subscribers OR groups/:group/subscribers/add': function() {\n\t\n});\n```\n\nTo fix the ugliness, breakup the route and escape any linebreaks:\n\n```javascript\nrouter.on({\n\t'pull \\\n\t-public -method=POST \\\n\tremove/cache/subscribers -> \\\n\t\tprofile/validate/SAVE_ARTICLE -> \\\n\t\t\tgroups/:group/subscribers OR \\\n\t\t\tgroups/:group/subscribers/add': function() {\n\t\t\n\t}\n})\n```\n\nYou can also split it up:\n\n```javascript\nrouter.on({\n\t'pull \\\n\tremove/cache/subscribers -> \\\n\tprofile/validate/SAVE_ARTICLE -> \\\n\t\tvalidate/group/subscribers': function() {\n\t\t\n\t}\n})\n\nrouter.on({\n\t'pull \\\n\t-public -method=POST \\\n\tvalidate/group/subscribers ->\n\t\tgroups/:group/subscribers OR \\\n\t\tgroups/:group/subscribers/add': function() {\n\t\t\n\t}\n})\n```\n\n\n### Methods            \n\n#### router.on(type[,listener])\n\nListens to the given routes\n\n- `type` - string or object. String would contain the route. Object would contain multiple routes / listeners\n- `listener` - function listening to the route given.           \n\n#### router.request(router)\n\nreturns the request builder         \n\n```javascript\n\nrouter.request('signup/user').\nquery({ username: 'blarg' }).\nheaders({ 'Content-Type': 'application/json' }).\n\n//called when the second param is present. \nsuccess(function(response) {\n\t\n}).\n\n//separated error from the response\nerror(function(err) {\n\t\n}).\n\n//called when there's a result, or error\nresponse(err, response) { \n\t\n}).\n\n//type of request: push, pull, collect, your own\npush();\n```                           \n\n#### router.push(route[, query][, headers])\n\n- `type` - the channel broadcast a message to.\n- `data` - the data to push to the given route\n- `options` - options for the given route\n\t- `meta` - tags to use to filter out listeners\n\t\n#### router.pull(route[, query][, headers][, callback])\n\nsame as push, but expects a response\n\n#### router.channels()\n                      \nreturns route expression\n\n#### request.write(chunk)\n             \nInitializes a streamed response. Great for sending files\n\n#### request.end([chunk]) \n                        \nEnds a response \n\n#### request.hasNext()\n                                                     \nReturns TRUE if there's a listener after the current one.\n\n#### request.next()\n\nMoves onto the next route.\n\n\n\n\n\n\n\n\n\n                                                                                                              \n\n",
  "_id": "beanpoll@0.2.18",
  "_from": "beanpoll"
}
