{
  "author": {
    "name": "Craig Condon"
  },
  "name": "structr-step",
  "version": "0.0.3",
  "repository": {
    "type": "git",
    "url": "git://github.com/crcn/structr-step.git"
  },
  "main": "./lib/index.js",
  "dependencies": {
    "tq": "0.0.x"
  },
  "devDependencies": {},
  "readme": "### Structr-step makes asyncronous function chainable\n\n\n### Projects using structr-step\n\n- [mongodblite](crcn/node-mongodblite)\n\t- see [this JS files](/crcn/node-mongodblite/blob/master/lib/collection.js)\n\n### Turn code from this\n\n```javascript\n\nvar structr = require(\"structr\"),\nfs = require(\"fs\");\n\nvar Config = structr({\n\n\t/**\n\t */\n\n\t\"__construct\": function(file) {\n\t\tthis.configFile = file;\n\n\t},\n\t\n\t\n\t/**\n\t * loads the config file\n\t */\n\n\t\"load\": function(next) {\n\n\t\tvar self = this;\n\n\t\t//make sure the confg file exists\n\t\tfs.stat(this.configFile, function(err, stat) {\n\n\t\t\t//if it doesn't exist, then set the config to an object, and\n\t\t\t//skip the rest\n\t\t\tif(err) {\n\t\t\t\tself._config = {};\n\t\t\t\treturn next();\n\t\t\t}\n\n\t\t\t//otherwise load it\n\t\t\tfs.readFile(self.configFile, function(err, content) {\n\n\t\t\t\t//and set the config\n\t\t\t\tnext(null, self._config = JSON.parse(content));\n\t\t\t})\n\n\t\t});\n\t},\n\n\t/**\n\t * returns the value in a config. This is blocked until\n\t * the config has been loaded\n\t */\n\n\t\"getValue\": function(key, next) {\n\t\treturn this._config[key];\n\t},\n\n\t/**\n\t * sets the vaue in the config\n\t */\n\n\t\"setValue\": function(key, value, next) {\n\t\tthis._config[key] = value;\n\t\tthis.save();\n\t\tnext();\n\t},\n\n\t/**\n\t * saves the config\n\t */\n\n\t\"step save\": function(next) {\n\t\tfs.writeFile(this.configFile, JSON.stringify(this._config), next);\n\t}\n});\n\n\n\nvar config = new Config(__dirname + \"/cache.json\");\nconfig.load(function(err) {\n\tif(err) return;\n\tvar value = config.getValue(\"name\");\n\t//do stuff...\n});\n```\n\n### Into This\n```javascript\n\nvar structr = require(\"structr\"),\nfs = require(\"fs\");\n\n//mix into structr\nstructr.mixin(require(\"../\"));\n\n\n\nvar Config = structr({\n\n\t/**\n\t */\n\n\t\"__construct\": function(file) {\n\t\tthis.configFile = file;\n\n\t\t//load the config before any methods can be\n\t\t//called\n\t\tthis.load();\n\t},\n\t\n\t\n\t/**\n\t * loads the config file\n\t */\n\n\t\"step load\": function(nextFn) {\n\t\tthis.step(\n\n\t\t\t//make sure the confg file exists\n\t\t\tfunction(next) {\n\t\t\t\tfs.stat(this.configFile, next);\n\t\t\t},\n\n\t\t\t//if it doesn't exist, then set the config to an object, and\n\t\t\t//skip the rest. Otherwise load it.\n\t\t\tfunction(err, stats, next) {\n\n\t\t\t\tif(err) {\n\t\t\t\t\tthis._config = {};\n\t\t\t\t\treturn nextFn(err);\n\t\t\t\t}\n\n\t\t\t\tfs.readFile(this.configFile, next);\n\t\t\t},\n\n\t\t\t//set the config, and finish\n\t\t\tfunction(err, content, next) {\n\t\t\t\tnext(null, this._config = JSON.parse(content));\n\t\t\t},\n\n\t\t\t//continue onto any other function called in this config\n\t\t\tnextFn\n\t\t);\n\t},\n\n\t/**\n\t * returns the value in a config. This is blocked until\n\t * the config has been loaded\n\t */\n\n\t\"step getValue\": function(key, next) {\n\t\tnext(null, this._config[key]);\n\t},\n\n\t/**\n\t * sets the vaue in the config\n\t */\n\n\t\"step setValue\": function(key, value, next) {\n\t\tthis._config[key] = value;\n\t\tthis.save();\n\t\tnext();\n\t},\n\n\t/**\n\t * saves the config\n\t */\n\n\t\"step save\": function(next) {\n\t\tfs.writeFile(this.configFile, JSON.stringify(this._config), next);\n\t}\n});\n\n\n\nvar config = new Config(__dirname + \"/cache.json\");\nconfig.getValue(\"name\", function(err, value) {\n\tif(!value) {\n\t\tconsole.log(\"config value does not exist, saving!\");\n\t\tconfig.setValue(\"name\", \"craig\");\n\t} else {\n\t\tconsole.log(\"hello %s!\", value);\n\t}\n});\n\n```",
  "readmeFilename": "README.md",
  "_id": "structr-step@0.0.3",
  "description": "",
  "_from": "structr-step"
}
